'''
Date 09/02/2023

Modifico la entrada de los inputs de ECIII-360. 
Con la idea de que no haya que añadir ningun "fake delay" 

De primeras voy a utilizar el metodo mas sucio para ir lo mas rapido posible

Este fichero se trata de una copia del fichero folder54 de la carpeta de enero (nuredduna), 
donde escaneaba el efecto de la inhibición de las cck sobre las pyramidales. En este se observaba 
cómo la intensidad de dicha inhibición retrasaba la fase de de las pyramidales. 
Como simple referencia escojo un valor intermedio de dicha inhibición. 

De momento no voya añadir la sigma que había considerado en la proyección CA3-CA1
'''

import warnings
warnings.filterwarnings("ignore")
from neuron import h
import numpy as np
import sys
import os
from neuron.units import ms
import time as tm
import pandas as pd
sys.path.append('/home/jaime/Desktop/hippocampus/files/')
import file_management
from network_hippocampus_ca1_new import *
from measurements import *
from parameters_alt_new import *
#from parameters_alt import *
from LFPsimpy import LfpElectrode

'''###########################################################################
                            Parameters
###########################################################################'''
simulation_time = 4000
tmin = 0
tmax = simulation_time

input0 = 0  # int(sys.argv[1]) # choosing the input generated by python (0) or neuron (1)
input1 = 10 # int(sys.argv[2]) # level of bursting, from 0 to 20, 10 is the one parameters have been optimized
input2 = int(sys.argv[3]) # seed of the external inputs, including bursting
input3 = int(sys.argv[4]) # seed of the background noise
input4 = int(sys.argv[5]) # variable to scan
input5 = 0 # int(sys.argv[6]) # second variabe to scan

noise_burst = np.linspace(0,1,21)[input1]
burst_level_label = str(input1)
jiseed = input2 # generation of external inputs
ibseed = input3 # background noise
external_inputs_label = str(jiseed)
background_noise_label = str(ibseed)

number_of_argv = len(sys.argv[1:])
argvs=''
for i in range(number_of_argv-1):
    argvs += sys.argv[1:][i]+'_'
argvs+=sys.argv[-1]

argvs = f"{input2}_{input3}_{input4}"
h.dt = 0.1
h.celsius = 34.0

DoMakeNoise = True
DoMakeExternalInputs = True
MakeCellStim         = False
MakeCellStim_python  = False

MakeNetStim = True

create_ca1_network = False
record_synapses    = False
record_lfp         = True

advance_time = np.linspace(0,20,21)

if input0 == 0:
    inputs_folder = '/home/jaime/Desktop/hippocampus/external_inputs_python/'
elif input0 == 1:
    inputs_folder = '/home/jaime/Desktop/hippocampus/external_inputs_neuron/'

current_folder = os.getcwd()
file_name = __file__
file_name = file_name.replace(current_folder,"") 
file_name = file_name.split('_')[-1][:-3] 
save_dir = os.path.join(current_folder, file_name)

'''#######################################################################
                  Parameters to optimize in CA1
            (All parameters written and explicited below)
            i) neurons-neurons
               a) weights
               b) nsyns (number of connections)
               c) type of synapsis
            ii) inputs-neurons
               a) weights
               b) nsyns (number of connections)
               c) type of synapsis
###########################################################################'''

'''###########################################################################
                    Neurons to neurons projections
###########################################################################'''

# weights
gain2 = np.linspace(0,2,21)
gain = np.linspace(0.0,1.5,21)# esta va con la conexion de abajo 
weights_neurons_neurons["pyr_ca1_to_bas_ca1"] = [[ gain[5]*2.341e-3, gain[5]*1.5*1.38e-3]]
weights_neurons_neurons["pyr_ca1_to_olm_ca1"] = [[ 0.969e-3, 0.7e-3]] # [0.36e-3+scale*0.7e-3, 0.7e-3]
weight_seq = np.linspace(0,2e-3,21)
weights_neurons_neurons["pyr_ca1_to_cck_ca1"] = [[ 0.0*weight_seq[input5],0]] #[[0.10*weight_seq[5], 0.1*weight_seq[5]]] #[4.05e-3], [ 4.05e-3 ]] #[[cck_inhibition[input4]],[cck_inhibition[input4]]]#[
gain = np.linspace(0.5,1,21)
weights_neurons_neurons["bas_ca1_to_bas_ca1"] = [[ gain[input4]*4.05e-3 ]] # initial value [[4.5e-3]]
weight = np.linspace(0,4e-3,21)
weights_neurons_neurons["bas_ca1_to_pyr_ca1"] = [[ 0.5*0.5*weight[10] ]] # initial [[0.576e-3]]
weights_neurons_neurons["olm_ca1_to_pyr_ca1"] = [[ 57.6e-3 ]]  # [0.8*72.0e-3] #*0.9

cck_inhibition = 8*np.linspace(0,1,21)*4.05e-4
gain = np.linspace(0,4,21)
weights_neurons_neurons["cck_ca1_to_pyr_ca1"] =  [[ cck_inhibition[10]], [cck_inhibition[10]]] #[[0.0],[0.0]] #[4.05e-3], [ 4.05e-3 ]] ##

weight = np.linspace(0,1e-3,21)
weights_neurons_neurons["cck_ca1_to_cck_ca1"] = [[ weight[10] ]]
# nsyns (number of projections)
ncons = np.arange(20,101,4)
nsyns_neurons_neurons["pyr_ca1_to_bas_ca1"] = [90] # [100] before the reduction of ca3
nsyns_neurons_neurons["pyr_ca1_to_olm_ca1"] = [10]
nsyns_neurons_neurons["pyr_ca1_to_cck_ca1"] = [90] # to be optimized
nsyns_neurons_neurons["bas_ca1_to_bas_ca1"] = [30] # [30] [60] before the reduction of ca3
nsyns_neurons_neurons["bas_ca1_to_pyr_ca1"] = [20] # [42] before the reduction of ca3
nsyns_neurons_neurons["olm_ca1_to_pyr_ca1"] = [10]
nsyns_neurons_neurons["cck_ca1_to_pyr_ca1"] = [30, 10]  #to optimizate keeping 70-30 of the total projections
nsyns_neurons_neurons["cck_ca1_to_cck_ca1"] = [30]

# syn (synapses type)
syn_neurons_neurons["pyr_ca1_to_bas_ca1"] = [["somaAMPA_pyr", "somaNMDA_pyr"]]
syn_neurons_neurons["pyr_ca1_to_olm_ca1"] = [["somaAMPA_pyr", "somaNMDA_pyr"]]
syn_neurons_neurons["pyr_ca1_to_cck_ca1"] = [["somaAMPA_pyr", "somaNMDA_pyr"]]
syn_neurons_neurons["bas_ca1_to_bas_ca1"] = [["somaGABA_bas"]]
syn_neurons_neurons["bas_ca1_to_pyr_ca1"] = [["somaGABA_bas"]]
syn_neurons_neurons["olm_ca1_to_pyr_ca1"] = [["Adend3GABA_olm"]] # previously  [["Adend3GABAf"]]
syn_neurons_neurons["cck_ca1_to_pyr_ca1"] = [["Adend2GABA_cck"], ["somaGABA_cck"]]
syn_neurons_neurons["cck_ca1_to_cck_ca1"] = [["somaGABA_cck"]]

# delay (synpatic delay)
delay_neurons_neurons["cck_ca1_to_pyr_ca1"] = [2.0,1.0]
delay_neurons_neurons["pyr_ca1_to_cck_ca1"] = [2.0,1.0]
delay_neurons_neurons["pyr_ca1_to_olm_ca1"] = [2.0,1.0]
delay_neurons_neurons["olm_ca1_to_pyr_ca1"] = [2.0,1.0]
delay_neurons_neurons["pyr_ca1_to_bas_ca1"] = [2.0,1.0]
delay_neurons_neurons["bas_ca1_to_pyr_ca1"] = [2.0,1.0]
delay_neurons_neurons["bas_ca1_to_bas_ca1"] = [2.0,1.0]
delay_neurons_neurons["cck_ca1_to_cck_ca1"] = [2.0,1.0]

'''###########################################################################
                    External inputs to neurons projections
###########################################################################'''
# weights
gain = np.linspace(1,10,21)
weights_inputs_neurons["sep_180_to_bas_ca1"] = [[ 6.4e-4 ]]
weights_inputs_neurons["sep_360_to_olm_ca1"] = [[ 3.2e-4 ]]
weights_inputs_neurons["sep_180_to_cck_ca1"] = [[ 3.2e-4 ]]
# those below null (by now)
weights_inputs_neurons["ec3_180_to_pyr_ca1"] = [[ 0.0, 0.0 ]]
#weights_inputs_neurons["ec3_180_to_bas_ca1"] = [[0.0,0.0]]
#weights_inputs_neurons["ec3_180_to_cck_ca1"] = [[0.0,0.0]]
gain = np.linspace(0,1,21)
weights_inputs_neurons["ec3_360_to_cck_ca1"] = [[ 4*5*3.3e-4*gain[12], 0.0*1.8e-4*gain[12]]] #[[3.3e-4, ]]
gain = np.linspace(0,1,21)
weights_inputs_neurons["ec3_360_to_bas_ca1"] = [[ 0.5*3.3e-4, 0.5*1.8e-4]]
weights_inputs_neurons["ec3_360_to_pyr_ca1"] = [[ 3.3e-4, 1.8e-4]] # [[2*3.3e-4, 2*1.8e-4]]#[[2*3.3e-4, 2*1.8e-4]]
weight = np.linspace(0,2,21)
weights_inputs_neurons["ec3_180_to_pyr_ca1"] = [[ 0.0*weight[8]*3.3e-4, 0.0*weight[8]*1.8e-4 ]] # [[2*3.3e-4, 2*1.8e-4]]#[[2*3.3e-4, 2*1.8e-4]]

# Schaffer colateral
weight_seq = np.linspace(0.75,1.25,21)*0.001045
gseq_pyr = np.linspace(0.3e-3, 0.7e-3, 21)
gseq_cck = np.linspace(1e-4,1e-3,21) # scale factor
delay_seq = np.linspace(2,8,21)

weight_seq = np.linspace(0,0.23e-3,21)
gain = np.linspace(0,1,21)
weights_inputs_neurons["pyr_ca3_to_pyr_ca1"] =  [[ gain[5]*0.32e-3, 4*gain[5]*0.5*0.23e-3]]#[[ 0.25*0.32e-3, 0.25*0.5*0.23e-3]]#weight_seq[input4] ]] # [[ gain[input4]*1.44e-4, gain[input5]*0.6e-4 ]] #[[1.5*weight_seq[5], 1.5*weight_seq[5]/2.0 ]] #[[ 1.5*weight_seq[4], 1.5*weight_seq[4]/2.0 ]]  # to be optimize

weight_seq = np.linspace(0,0.4e-3,21)
gain = np.linspace(0,2,21)
weights_inputs_neurons["pyr_ca3_to_bas_ca1"] = [ [0.8*0.5*3.3e-4, 4*0.8*0.5*1.8e-4] ] #[[ 0.9e-4,  0.5e-4 ]]
gain = np.linspace(0,2,21)
weights_inputs_neurons["pyr_ca3_to_cck_ca1"] = [ [ 0.25*0.16e-3, 0.25*0.014e-3 ] ] # to be optimize

ncon = np.linspace(25,125,21).astype(int)
nsyns_inputs_neurons["pyr_ca3_to_pyr_ca1"] = [ 125 ]  # theoretically 160 to be optimized
nsyns_inputs_neurons["pyr_ca3_to_bas_ca1"] = [ 125 ]  # theoretically 160 to be optimized
nsyns_inputs_neurons["pyr_ca3_to_cck_ca1"] = [ 125 ]  # theoretically 160, to be optimized

delay_seq = np.arange(2,23,1)
delay_external = 10.0
delay_CA3 = 5.0
sigma_seq = np.linspace(0,20,21)
delay_inputs_neurons["pyr_ca3_to_pyr_ca1"] = [ delay_CA3, 10.0 ]# [delay_seq[input5]]
delay_inputs_neurons["pyr_ca3_to_bas_ca1"] = [ delay_CA3, 1.0 ]
delay_inputs_neurons["pyr_ca3_to_cck_ca1"] = [ delay_CA3, 1.0 ]

delay_inputs_neurons["sep_360_to_olm_ca1"] = [ delay_external,1.0 ]
delay_inputs_neurons["sep_180_to_bas_ca1"] = [ delay_external,1.0 ]
delay_inputs_neurons["sep_180_to_cck_ca1"] = [ delay_external,1.0 ]

delay_inputs_neurons["ec3_360_to_cck_ca1"] = [ delay_external,1.0 ]
delay_inputs_neurons["ec3_360_to_pyr_ca1"] = [ delay_external,1.0 ]
delay_inputs_neurons["ec3_360_to_bas_ca1"] = [ delay_external,1.0 ]

# not used yet
delay_inputs_neurons["ec3_180_to_pyr_ca1"] = [ delay_external,1.0 ]
delay_inputs_neurons["ec3_180_to_cck_ca1"] = [ delay_external,1.0 ]
delay_inputs_neurons["ec3_180_to_bas_ca1"] = [ delay_external,1.0 ]

# nsyns (number of projections)
nsyns_inputs_neurons["sep_180_to_bas_ca1"] = [10]
nsyns_inputs_neurons["sep_360_to_olm_ca1"] = [10]
nsyns_inputs_neurons["sep_180_to_cck_ca1"] = [10]
nsyns_inputs_neurons["ec3_180_to_pyr_ca1"] = [25]
# nsyns_inputs_neurons["ec3_180_to_bas_ca1"] = [25]
# nsyns_inputs_neurons["ec3_180_to_cck_ca1"] = [25]
nsyns_inputs_neurons["ec3_360_to_pyr_ca1"] = [25]
nsyns_inputs_neurons["ec3_360_to_bas_ca1"] = [25]
nsyns_inputs_neurons["ec3_360_to_cck_ca1"] = [25]

# syn
syn_inputs_neurons["sep_180_to_bas_ca1"] = [["somaGABA_sep180"]]
syn_inputs_neurons["sep_360_to_olm_ca1"] = [["somaGABA_sep360"]]
syn_inputs_neurons["sep_180_to_cck_ca1"] = [["somaGABA_sep180"]]
syn_inputs_neurons["ec3_180_to_pyr_ca1"] = [["Adend3AMPA_ec3180","Adend3NMDA_ec3180"]]
# syn_inputs_neurons["ec3_180_to_bas_ca1"] = [["somaAMPAf", "somaNMDA"]]
# syn_inputs_neurons["ec3_180_to_cck_ca1"] = [["somaAMPAf", "somaNMDA"]]
syn_inputs_neurons["ec3_360_to_pyr_ca1"] = [["Adend3AMPA_ec3360", "Adend3NMDA_ec3360"]]
syn_inputs_neurons["ec3_360_to_bas_ca1"] = [["somaAMPA_ec3360", "somaNMDA_ec3360"]]
syn_inputs_neurons["ec3_360_to_cck_ca1"] = [["somaAMPA_ec3360", "somaNMDA_ec3360"]]
syn_inputs_neurons["pyr_ca3_to_pyr_ca1"] = [["Adend1AMPA_pyrCA3", "Adend1NMDA_pyrCA3"]]
syn_inputs_neurons["pyr_ca3_to_bas_ca1"] = [["somaAMPA_pyrCA3", "somaNMDA_pyrCA3"]]
syn_inputs_neurons["pyr_ca3_to_cck_ca1"] = [["somaAMPA_pyrCA3", "somaNMDA_pyrCA3"]]

'''###########################################################################
                    External background noise
###########################################################################'''
weights_noise_neurons["bas_ca1"]["somaAMPA_noise"]   = 0.0125e-3
gain = np.linspace(1,10,21)
weights_noise_neurons["pyr_ca1"]["somaAMPA_noise"]   = 5*0.0125e-3
weights_noise_neurons["pyr_ca1"]["Adend3AMPA_noise"] = 0.0125e-3

##############################################################################
# remove the inhibition from the non-basket interneurons
#weights_neurons_neurons["olm_ca1_to_pyr_ca1"] = [[0]]
#weights_neurons_neurons["cck_ca1_to_pyr_ca1"] = [[0], [0]] 
#weights_neurons_neurons["cck_ca1_to_cck_ca1"] = [[0]]

''' ###########################################################################
                    Some previous functions
############################################################################'''
tick = tm.time()
current_dir = os.getcwd()

h.load_file("stdrun.hoc")
def fi():
    for i in range(0,int(simulation_time),100):
        h.cvode.event(i, "print " + str(i))

def change_bursting():
    w_new = net.burst_basal_ncl_[0].weight[0]
    for nc in net.burst_var_ncl_:
        nc.weight[0] = w_new
    for nc in net.burst_basal_ncl_:
        nc.weight[0] = 0.0

def unify_data(variable, net, cells = "cell_ca3", nr=1):
    cell = net.__dict__[cells][0]
    print( list(np.round( cell.__dict__[variable], nr) ))
    local_data = { cell.id: list( np.round(cell.__dict__[variable],nr) ) for cell in net.__dict__[cells] }
    all_data = pc.py_alltoall( [local_data] + [None] * (pc.nhost() - 1) )
    return all_data

'''###########################################################################
                           saving the currents
###########################################################################'''


synlist = [ "Adend3GABA_olm","Adend3AMPA_ec3360","Adend3NMDA_ec3360", "Adend3GABA_noise", "Adend3AMPA_noise",
             "Adend2GABA_cck",
             "Adend1AMPA_pyrCA3", "Adend1NMDA_pyrCA3",
             "somaGABA_bas", "somaGABA_cck", "somaAMPA_noise", "somaGABA_noise"]

'''############################################################################
                                The network
#############################################################################'''
record_mp = {"soma":False,"Bdend": False, "Adend1":False, "Adend2":False, "Adend3":False}
net = Network( weights_inputs_neurons  = weights_inputs_neurons,
               nsyns_inputs_neurons    = nsyns_inputs_neurons,
               syn_inputs_neurons      = syn_inputs_neurons,
               weights_neurons_neurons = weights_neurons_neurons,
               nsyns_neurons_neurons   = nsyns_neurons_neurons,
               syn_neurons_neurons     = syn_neurons_neurons,
               weights_noise_neurons   = weights_noise_neurons,
               delay_inputs_neurons    = delay_inputs_neurons,
               delay_neurons_neurons   = delay_neurons_neurons,
               noise_burst = noise_burst,
               bseed=27*(2*ibseed+1),   # semilla del ruido
               iseed=3421*(2*jiseed+1), # semilla para los inputs
               create_ca1_network = create_ca1_network,
               DoMakeNoise = DoMakeNoise,
               DoMakeExternalInputs = DoMakeExternalInputs,
               MakeCellStim = MakeCellStim,
               MakeNetStim  = MakeNetStim,
               MakeCellStim_python = MakeCellStim_python,
               inputs_folder = inputs_folder,
               burst_level_label = burst_level_label,
               external_inputs_label = external_inputs_label,
               background_noise_label = background_noise_label,
               n_pyr_ca3 = 800,
               n_bas_ca3 = 100,
               n_olm_ca3 = 30,
               n_pyr_ca1 = 800,
               n_bas_ca1 = 100,
               n_olm_ca1 = 30,
               n_cck_ca1 = 70,
               connections = True,
               nseg_pyr= 3, 
               record_mp = record_mp)

tau2seq = np.linspace(1,5,21)
tauNMDAseq = np.linspace(15,40,21)
for cell in net.cck_ca1.cell:
    cell.somaInj.amp = 32.5*1e-3 # fixed 15/11
for cell in net.pyr_ca1.cell:
    cell.Adend3GABA_olm.syn.tau2 = 20.0
# for cell in net.pyr_ca1.cell: # la putada es que aqui estoy cambiando tambien las sinapsis de las basket. 
#     # habria que usar el fichero de github
#     cell.Adend2GABA_cck.syn.tau2 = tau2seq[input4]
#     cell.somaGABA_cck.syn.tau2   = tau2seq[input4]
for cell in net.cck_ca1.cell: 
    cell.somaAMPA_ec3360.syn.tau2 = 2.5#tau2seq[input4]
for cell in net.pyr_ca1.cell: 
    cell.Adend1NMDA_pyrCA3.syn.tau1NMDA = 15#tauNMDAseq[input4]
    cell.Adend2GABA_cck.syn.tau2 = 4.0#tau2seq[input4]
    cell.somaGABA_cck.syn.tau2   = 4.0#tau2seq[input4]
    
# modification of the threshold of the cck 
for cell in net.cck_ca1.cell: 
    cell.spike_detector.threshold = -10.0
    
net.set_noise_inputs(simulation_time) # set background noise and external input
if net.MakeNetStim:
    net.init_NetStims()  # init rngs of background
if net.MakeCellStim:
    if not net.MakeCellStim_python:
        net.init_CellStims() # init rngs of external inputs

# record synaptic current in the pyramidal neurons:

for cell in net.pyr_ca1.cell:
    cell.syn_list = synlist
    cell.record_synapses()


'''###########################################################################
                     external inputs vecstims
############################################################################'''

inputs, vecstims = [],[]
net.inputs_list = []
net.vsl_ = []

if net.DoMakeExternalInputs:
    print("external inputs with vecstims")
    print(net.external_inputs_data.keys())
    for key in net.external_inputs_data.keys():
        if key.endswith("ca1"):
            idv      = net.external_inputs_data[key]["idv"]
            spikes   = net.external_inputs_data[key]["spikes"]
            trg      = net.external_inputs_data[key]["population"]
            syn_list = net.external_inputs_data[key]["synapses"]
            delays   = net.external_inputs_data[key]["delays"]
            w_list   = net.external_inputs_data[key]["weights"]
            conn     = net.external_inputs_data[key]["connectivity"]
            if key.startswith("ec3_360"): # "quick solution to make cck spike before"
                spikes -= 10
            for k,conn_ in enumerate(conn):
                for post_id, all_pre in enumerate(conn_):
                    net.inputs_list.append([ ])
                    for j, pre_id in enumerate(all_pre):
                        idvs = np.where(idv==pre_id)[0]
                        net.inputs_list[-1].append( np.sort(spikes[idvs]))
                        inputs.append(h.Vector( np.sort(spikes[idvs]) ))
                        vecstims.append(h.VecStim())
                        vecstims[-1].play(inputs[-1])

                        spike_list = vecstims[-1]
                        net.vsl_.append(spike_list)
                        for syn,w in zip(syn_list[k], w_list[k]):
                            net.ncl_.append(h.NetCon(spike_list, trg.cell[post_id].__dict__[syn].syn, 0, delays[k][j,post_id], w))
    tock = tm.time()
    diff = tock-tick
    horas = int(diff/3600)
    diff  = diff-horas*3600
    mint  = int(diff/60)
    diff  = diff-mint*60
    seg   = int(diff)

    print('Vecstim done after:', horas,'h', mint, 'min', seg, 's')
''' #######################################################################'''

pc = h.ParallelContext()
pc.set_maxstep(100*ms)
t = h.Vector().record(h._ref_t)
h.celsius = 34.0
# h.steps_per_ms = 1/h.dt
h.dt = 0.1

print('----')
print(net.n_pop)
if record_lfp:
    # electrode_y_coords = np.arange(0,850,50)
    zcoords = [-100,10,85,235, 385]
    # electrode_number = len(electrode_y_coords)
    electrode = {}
    electrode["ca1"] = [ ]
    for i,z in enumerate(zcoords):
        electrode["ca1"].append( LfpElectrode(x=25.0, y=25.0, z=z, sampling_period=2, neuron_type = "Pyramidal CA3"))

# h.tstop = simulation_time
# h.stdinit()
h.init()
h.finitialize()
h.fcurrent()
h.frecord_init()
h.tstop=simulation_time
h.dt = 0.1
print(h.celsius)
h.celsius = 34

#sys.exit()
pc.psolve(simulation_time*ms) # simulation running starts
#if record_synapses:
#    net.get_synaptic_currents() # get the sum of all incoming synaptic currents in each compartiment
t = np.array(t.to_python())
tock = tm.time()
diff  = tock-tick
horas = int(diff/3600)
diff  = diff-horas*3600
mint  = int(diff/60)
diff  = diff-mint*60
seg   = int(diff)
print("Simulation done after", horas,'h', mint, 'min', seg, 's')

################################################################################
#pc.py_alltoall: get all the results in host 0
################################################################################
print( net.pyr_ca1.cell[0].soma(0.5)._ref_v )
all_spikes, all_volt, lfp, ica = {},{},{},{}

all_spikes["ca1"] = unify_data("spike_times", net, cells="cell_ca1")
# all_volt["ca1"]   = unify_data("soma_volt",   net, cells="cell_ca1",nr=4)
# lfp["ca3"]       = np.array(pc.py_alltoall([net.vlfp_ca3]+[None]*(pc.nhost()-1)))
nets = [net.pop_ca1]

if record_synapses:
    for subnet in nets:
        for po in subnet:
            seclist = po.cell[0].sec_list
            for sec in seclist:
                for key in po.__dict__[sec+"_isyn"].keys():
                    po.__dict__[sec+"_isyn"][key] = np.array(pc.py_alltoall( [ po.__dict__[sec+"_isyn"][key] ]+[None]*(pc.nhost()-1)))

if pc.id() == 0:
    tock = tm.time()
    diff = tock-tick
    horas = int(diff/3600)
    diff  = diff-horas*3600
    mint  = int(diff/60)
    diff  = diff-mint*60
    seg   = int(diff)

    print('Simulation time with resolution dt = ', h.dt ,' ms :')
    print('_________________')
    print(' ')
    print(horas,'h', mint, 'min', seg, 's')

    all_currents = {}
    nets, regions = [net.pop_ca1],["ca1"]
    extra_label_title = "only_ca1_"

    if record_synapses:
        for subnet,region in zip(nets, regions):
            for po, neuron_type in zip(subnet,["pyr","bas","olm"]):
                seclist = po.cell[0].sec_list
                for sec in seclist:
                    all = np.ones(len(t))*0.0
                    for key in po.__dict__[sec+"_isyn"].keys():
                        po.__dict__[sec+"_isyn"][key] = np.sum(po.__dict__[sec+"_isyn"][key], axis=0)/po.n
                        lb=region+"_"+neuron_type+"_"+sec+"_"+key
                        all_currents[lb] = po.__dict__[sec+"_isyn"][key]
                        all += po.__dict__[sec+"_isyn"][key]

                    po.__dict__[sec+"_isyn"]["all"] = all
                    lb=region+"_"+neuron_type+"_"+sec+"_all"
                    all_currents[lb] = po.__dict__[sec+"_isyn"]["all"]

    # lfp["ca3"]= np.sum(lfp["ca3"], axis=0)/net.pyr_ca3.n
    # if net.create_ca1_network:
    #    lfp["ca1"]= np.sum(lfp["ca1"], axis=0)/net.pyr_ca1.n

    #data_volt   = process_volt_data( all_volt, net, only_ca1=True)
    data_spikes = process_spike_data( all_spikes,net, only_ca1 = True)

    # save_dir = "/home/jaime/Desktop/hippocampus/external_inputs/"
    # save_dir = os.path.join(save_dir, str(input1))
    # file_management.save_lzma(data_spikes["ca3"]["pyr"],"external_inputs_"+argvs+"_pyr_ca3",parent_dir=save_dir)

    # save_dir = os.path.join(current_folder, "ca3_data")
    # save_dir = os.path.join( save_dir, str(input1) )

    if record_lfp:
        lfp["ca1"], ica["ca1"] = [], []
        for lfp_ in electrode["ca1"]:
            lfp["ca1"].append( np.array(lfp_.values) )
            ica["ca1"].append( np.array(lfp_.values_per_section) )

        title = "lfp_"+extra_label_title+argvs
        file_management.save_lzma(lfp, title, parent_dir=save_dir)
        title = "ica_"+extra_label_title+argvs
        file_management.save_lzma(lfp, title, parent_dir=save_dir)

    title = "spikes_"+extra_label_title+argvs
    file_management.save_lzma(data_spikes,title,parent_dir=save_dir)

    syn_currents = dict.fromkeys(synlist)
    # averaging the currents: 
    for key in synlist:
        syn_currents[key] = [] 
        syn_currents[key+"_std"] = []
        for cell in net.pyr_ca1.cell:
            syn_currents[key].append( cell.__dict__["i"+key].to_python() )
        syn_currents[key+"_std"] = np.std( syn_currents[key], axis=0)[::10] # dimension reduction 
        syn_currents[key] = np.mean(syn_currents[key], axis=0)[::10]
    
    pdsyn = pd.DataFrame(syn_currents, columns=syn_currents.keys())
    title = "syn_"+extra_label_title+argvs
    file_management.save_lzma(pdsyn,title,parent_dir=save_dir)

    # title = "volt_"+extra_label_title+argvs
    # file_management.save_lzma(data_volt, title, parent_dir=save_dir)

    # title = "noise_background_"+extra_label_title+argvs
    # file_management.save_lzma(net.netstims_tvec, title, parent_dir=save_dir)
    # title = "noise_background_"+extra_label_title+argvs
    # file_management.save_lzma(net.netstims_ivec, title, parent_dir=save_dir)
    # title = "external_inputs_tvec_"+extra_label_title+argvs
    # file_management.save_lzma(external_inputs_tvec, title, parent_dir=save_dir)
    # title = "external_inputs_idvec"+extra_label_title+argvs
    # file_management.save_lzma(external_inputs_ivec, title, parent_dir=save_dir)

    # os.chdir(save_dir)
    # raster_plot(net,all_spikes, tmin, tmax, figtitle="raster_plot_"+argvs)
    # plot_lfp(net,t,lfp,tmin,tmax, figtitle="lfp_plot_"+argvs)
    # spiking_distributions(net, all_spikes, tmin, tmax, figtitle="spiking_distribution_"+argvs)

    if record_synapses:
        incoming_currents_plots(net,t,tmin,tmax,figtitle="currents_plot_"+argvs)
        title = "currents_"+extra_label_title+argvs
        df=pandas.DataFrame(all_currents)
        file_management.save_lzma(df,title,parent_dir=save_dir)

    tock = tm.time()
    diff = tock-tick
    horas = int(diff/3600)
    diff  = diff-horas*3600
    mint  = int(diff/60)
    diff  = diff-mint*60
    seg   = int(diff)
    
    print("All data saved after ", horas,'h', mint, 'min', seg, 's')

error_file  = "error"+save_dir[-2:]+"_"+argvs+".log"
output_file = "output"+save_dir[-2:]+"_"+argvs+".dat"
os.remove(error_file)
os.remove(output_file)

print('data saved')
pc.barrier()
pc.done()
h.quit()

