'''
Date 09/02/2023

Modifico la entrada de los inputs de ECIII-360. 
Con la idea de que no haya que añadir ningun "fake delay" 

De primeras voy a utilizar el metodo mas sucio para ir lo mas rapido posible

Este fichero se trata de una copia del fichero folder54 de la carpeta de enero (nuredduna), 
donde escaneaba el efecto de la inhibición de las cck sobre las pyramidales. En este se observaba 
cómo la intensidad de dicha inhibición retrasaba la fase de de las pyramidales. 
Como simple referencia escojo un valor intermedio de dicha inhibición. 

De momento no voya añadir la sigma que había considerado en la proyección CA3-CA1
'''

import warnings
warnings.filterwarnings("ignore")
from neuron import h
import numpy as np
import sys
import os
from neuron.units import ms
import time as tm
sys.path.append('/home/dimitrios/Neurons/CA1model/files/')
import file_management
from network_hippocampus_ca1_paral import *
from measurements import *
from parameters_alt import *
#from parameters_alt import *
from LFPsimpy import LfpElectrode

'''###########################################################################
                            Parameters
###########################################################################'''
simulation_time = 30000
tmin = 0
tmax = simulation_time

input0 = int(sys.argv[1])  # int(sys.argv[1]) # choosing the input generated by python (0) or neuron (1)
input1 = 10 # int(sys.argv[2]) # level of bursting, from 0 to 20, 10 is the one parameters have been optimized
input2 = int(sys.argv[3]) #seed of noise 
input3 = int(sys.argv[4]) #parameter 1
input4 = int(sys.argv[5]) #parameter 2

noise_burst = np.linspace(0,1,21)[input1]
burst_level_label = str(input1)
jiseed = input2 # generation of external inputs
ibseed = input0 # background noise
external_inputs_label = str(jiseed)
#background_noise_label = str(ibseed)
inp_sigma_ind = 0

argvs = f"{input0}_{input2}_{input3}_{input4}"
h.dt = 0.1
h.celsius = 34.0

DoMakeNoise = True
DoMakeExternalInputs = True
MakeCellStim         = False
MakeCellStim_python  = False

MakeNetStim = True

create_ca1_network = False
record_synapses    = False
record_lfp         = True

advance_time = np.linspace(0,20,21)

inputs_folder = '/home/dimitrios/Neurons/CA1model/external_inputs_test/distrWidthIndex'+str(inp_sigma_ind)

current_folder = os.getcwd()
file_name = __file__
file_name = file_name.replace(current_folder,"") 
file_name = file_name.split('_')[-1][:-3] 
save_dir = os.path.join(current_folder, file_name)

'''#######################################################################
                  Parameters to optimize in CA1
            (All parameters written and explicited below)
            i) neurons-neurons
               a) weights
               b) nsyns (number of connections)
               c) type of synapsis
            ii) inputs-neurons
               a) weights
               b) nsyns (number of connections)
               c) type of synapsis
###########################################################################'''

'''###########################################################################
                    Neurons to neurons projections
###########################################################################'''

# weights
gain2 = np.linspace(0,2,21)
gain = np.linspace(0.0,1.5,21)# esta va con la conexion de abajo 
weights_neurons_neurons["pyr_ca1_to_bas_ca1"] = [[ gain[5]*2.341e-3, gain[5]*1.5*1.38e-3]]
weights_neurons_neurons["pyr_ca1_to_olm_ca1"] = [[ 0.969e-3, 0.7e-3]] # [0.36e-3+scale*0.7e-3, 0.7e-3]
weight_seq = np.linspace(0,2e-3,21)

weights_neurons_neurons["pyr_ca1_to_cck_ca1"] = [[ 0.0*weight_seq[0],0]] #[[0.10*weight_seq[5], 0.1*weight_seq[5]]] #[4.05e-3], [ 4.05e-3 ]] #[[cck_inhibition[input4]],[cck_inhibition[input4]]]#[
gain = np.linspace(0.5,1,21)
weights_neurons_neurons["bas_ca1_to_bas_ca1"] = [[ gain[10]*4.05e-3 ]] # initial value [[4.5e-3]]
weight = np.linspace(0,4e-3,21)
weights_neurons_neurons["bas_ca1_to_pyr_ca1"] = [[ 0.5*0.5*weight[10] ]] # initial [[0.576e-3]]

weights_neurons_neurons["olm_ca1_to_pyr_ca1"] = [[ 57.6e-3]]  # [0.8*72.0e-3] #*0.9

cck_inhibition = 8*np.linspace(0,1,21)*4.05e-4
cck_ca1 = np.linspace(0,2,11)[input4]
gain = np.linspace(0,4,21)
weights_neurons_neurons["cck_ca1_to_pyr_ca1"] =  [[ cck_inhibition[10]*cck_ca1], [cck_inhibition[10]*cck_ca1]] #[[0.0],[0.0]] #[4.05e-3], [ 4.05e-3 ]] ##

weight = np.linspace(0,1e-3,21)
weights_neurons_neurons["cck_ca1_to_cck_ca1"] = [[ weight[10] ]]
# nsyns (number of projections)
ncons = np.arange(20,101,4)
nsyns_neurons_neurons["pyr_ca1_to_bas_ca1"] = [90] # [100] before the reduction of ca3
nsyns_neurons_neurons["pyr_ca1_to_olm_ca1"] = [10]
nsyns_neurons_neurons["pyr_ca1_to_cck_ca1"] = [90] # to be optimized
nsyns_neurons_neurons["bas_ca1_to_bas_ca1"] = [30] # [30] [60] before the reduction of ca3
nsyns_neurons_neurons["bas_ca1_to_pyr_ca1"] = [20] # [42] before the reduction of ca3
nsyns_neurons_neurons["olm_ca1_to_pyr_ca1"] = [10]
nsyns_neurons_neurons["cck_ca1_to_pyr_ca1"] = [30, 10]  #to optimizate keeping 70-30 of the total projections
nsyns_neurons_neurons["cck_ca1_to_cck_ca1"] = [30]

# syn (synapses type)
syn_neurons_neurons["pyr_ca1_to_bas_ca1"] = [["somaAMPA_pyr", "somaNMDA_pyr"]]
syn_neurons_neurons["pyr_ca1_to_olm_ca1"] = [["somaAMPA_pyr", "somaNMDA_pyr"]]
syn_neurons_neurons["pyr_ca1_to_cck_ca1"] = [["somaAMPA_pyr", "somaNMDA_pyr"]]
syn_neurons_neurons["bas_ca1_to_bas_ca1"] = [["somaGABA_bas"]]
syn_neurons_neurons["bas_ca1_to_pyr_ca1"] = [["somaGABA_bas"]]
syn_neurons_neurons["olm_ca1_to_pyr_ca1"] = [["Adend3GABA_olm"]] # previously  [["Adend3GABAf"]]
syn_neurons_neurons["cck_ca1_to_pyr_ca1"] = [["Adend2GABA_cck"], ["somaGABA_cck"]]
syn_neurons_neurons["cck_ca1_to_cck_ca1"] = [["somaGABA_cck"]]

# delay (synpatic delay)
delay_neurons_neurons["cck_ca1_to_pyr_ca1"] = [2.0,1.0]
delay_neurons_neurons["pyr_ca1_to_cck_ca1"] = [2.0,1.0]
delay_neurons_neurons["pyr_ca1_to_olm_ca1"] = [2.0,1.0]
delay_neurons_neurons["olm_ca1_to_pyr_ca1"] = [2.0,1.0]
delay_neurons_neurons["pyr_ca1_to_bas_ca1"] = [2.0,1.0]
delay_neurons_neurons["bas_ca1_to_pyr_ca1"] = [2.0,1.0]
delay_neurons_neurons["bas_ca1_to_bas_ca1"] = [2.0,1.0]
delay_neurons_neurons["cck_ca1_to_cck_ca1"] = [2.0,1.0]

'''###########################################################################
                    External inputs to neurons projections
###########################################################################'''
# weights
gain = np.linspace(1,10,21)
weights_inputs_neurons["sep_180_to_bas_ca1"] = [[ 6.4e-4 ]]
weights_inputs_neurons["sep_360_to_olm_ca1"] = [[ 3.2e-4 ]]
weights_inputs_neurons["sep_180_to_cck_ca1"] = [[ 3.2e-4 ]]
# those below null (by now)
weights_inputs_neurons["ec3_180_to_pyr_ca1"] = [[ 0.0, 0.0 ]]
#weights_inputs_neurons["ec3_180_to_bas_ca1"] = [[0.0,0.0]]
#weights_inputs_neurons["ec3_180_to_cck_ca1"] = [[0.0,0.0]]
gain = np.linspace(0,1,21)
inp_cck = np.linspace(0,1,11)[input3]
weights_inputs_neurons["ec3_360_to_cck_ca1"] = [[ 4*5*3.3e-4*gain[12]*inp_cck, 1.8e-4*gain[12]*inp_cck]] #[[3.3e-4, ]]
gain = np.linspace(0,1,21)
weights_inputs_neurons["ec3_360_to_bas_ca1"] = [[ 0.5*3.3e-4, 0.5*1.8e-4]]
weights_inputs_neurons["ec3_360_to_pyr_ca1"] = [[ 3.3e-4, 1.8e-4]] # [[2*3.3e-4, 2*1.8e-4]]#[[2*3.3e-4, 2*1.8e-4]]
weight = np.linspace(0,2,21)
weights_inputs_neurons["ec3_180_to_pyr_ca1"] = [[ 0.0*weight[8]*3.3e-4, 0.0*weight[8]*1.8e-4 ]] # [[2*3.3e-4, 2*1.8e-4]]#[[2*3.3e-4, 2*1.8e-4]]

# Schaffer colateral
weight_seq = np.linspace(0.75,1.25,21)*0.001045
gseq_pyr = np.linspace(0.3e-3, 0.7e-3, 21)
gseq_cck = np.linspace(1e-4,1e-3,21) # scale factor
delay_seq = np.linspace(2,8,21)

weight_seq = np.linspace(0,0.23e-3,21)
gain = np.linspace(0.25,0.5,21)
pyr_pyr = np.linspace(0,2,11)[4]
weights_inputs_neurons["pyr_ca3_to_pyr_ca1"] =  [[ pyr_pyr*gain[10]*0.75*0.32e-3, pyr_pyr*4*0.25*0.5*0.23e-3 ]]#[[ 0.25*0.32e-3, 0.25*0.5*0.23e-3]]#weight_seq[input4] ]] # [[ gain[input4]*1.44e-4, gain[input5]*0.6e-4 ]] #[[1.5*weight_seq[5], 1.5*weight_seq[5]/2.0 ]] #[[ 1.5*weight_seq[4], 1.5*weight_seq[4]/2.0 ]]  # to be optimize

weight_seq = np.linspace(0,0.4e-3,21)
gain = np.linspace(0,2,21)
weights_inputs_neurons["pyr_ca3_to_bas_ca1"] = [ [0.8*0.5*3.3e-4, 4*0.8*0.5*1.8e-4] ] #[[ 0.9e-4,  0.5e-4 ]]
gain = np.linspace(0,2,21)
weights_inputs_neurons["pyr_ca3_to_cck_ca1"] = [ [ 0.25*0.16e-3*inp_cck, 0.25*0.014e-3*inp_cck ] ] # to be optimize

ncon = np.linspace(25,125,21).astype(int)
nsyns_inputs_neurons["pyr_ca3_to_pyr_ca1"] = [ 100 ]  # theoretically 160 to be optimized
nsyns_inputs_neurons["pyr_ca3_to_bas_ca1"] = [ 100 ]  # theoretically 160 to be optimized
nsyns_inputs_neurons["pyr_ca3_to_cck_ca1"] = [ 100 ]  # theoretically 160, to be optimized

delay_seq = np.arange(2,23,1)
delay_external = 10.0
delay_CA3 = 5.0
sigma_seq = np.linspace(0,20,21)
delay_inputs_neurons["pyr_ca3_to_pyr_ca1"] = [ delay_CA3, 10.0 ]# [delay_seq[input5]]
delay_inputs_neurons["pyr_ca3_to_bas_ca1"] = [ delay_CA3, 1.0 ]
delay_inputs_neurons["pyr_ca3_to_cck_ca1"] = [ delay_CA3, 1.0 ]

delay_inputs_neurons["sep_360_to_olm_ca1"] = [ delay_external,1.0 ]
delay_inputs_neurons["sep_180_to_bas_ca1"] = [ delay_external,1.0 ]
delay_inputs_neurons["sep_180_to_cck_ca1"] = [ delay_external,1.0 ]

delay_inputs_neurons["ec3_360_to_cck_ca1"] = [ delay_external,1.0 ]
delay_inputs_neurons["ec3_360_to_pyr_ca1"] = [ delay_external,1.0 ]
delay_inputs_neurons["ec3_360_to_bas_ca1"] = [ delay_external,1.0 ]

# not used yet
delay_inputs_neurons["ec3_180_to_pyr_ca1"] = [ delay_external,1.0 ]
delay_inputs_neurons["ec3_180_to_cck_ca1"] = [ delay_external,1.0 ]
delay_inputs_neurons["ec3_180_to_bas_ca1"] = [ delay_external,1.0 ]

# nsyns (number of projections)
nsyns_inputs_neurons["sep_180_to_bas_ca1"] = [10]
nsyns_inputs_neurons["sep_360_to_olm_ca1"] = [10]
nsyns_inputs_neurons["sep_180_to_cck_ca1"] = [10]
nsyns_inputs_neurons["ec3_180_to_pyr_ca1"] = [25]
# nsyns_inputs_neurons["ec3_180_to_bas_ca1"] = [25]
# nsyns_inputs_neurons["ec3_180_to_cck_ca1"] = [25]
nsyns_inputs_neurons["ec3_360_to_pyr_ca1"] = [25]
nsyns_inputs_neurons["ec3_360_to_bas_ca1"] = [25]
nsyns_inputs_neurons["ec3_360_to_cck_ca1"] = [25]

# syn
syn_inputs_neurons["sep_180_to_bas_ca1"] = [["somaGABA_sep180"]]
syn_inputs_neurons["sep_360_to_olm_ca1"] = [["somaGABA_sep360"]]
syn_inputs_neurons["sep_180_to_cck_ca1"] = [["somaGABA_sep180"]]
syn_inputs_neurons["ec3_180_to_pyr_ca1"] = [["Adend3AMPA_ec3180","Adend3NMDA_ec3180"]]
# syn_inputs_neurons["ec3_180_to_bas_ca1"] = [["somaAMPAf", "somaNMDA"]]
# syn_inputs_neurons["ec3_180_to_cck_ca1"] = [["somaAMPAf", "somaNMDA"]]
syn_inputs_neurons["ec3_360_to_pyr_ca1"] = [["Adend3AMPA_ec3360", "Adend3NMDA_ec3360"]]
syn_inputs_neurons["ec3_360_to_bas_ca1"] = [["somaAMPA_ec3360", "somaNMDA_ec3360"]]
syn_inputs_neurons["ec3_360_to_cck_ca1"] = [["somaAMPA_ec3360", "somaNMDA_ec3360"]]
syn_inputs_neurons["pyr_ca3_to_pyr_ca1"] = [["Adend1AMPA_pyrCA3", "Adend1NMDA_pyrCA3"]]
syn_inputs_neurons["pyr_ca3_to_bas_ca1"] = [["somaAMPA_pyrCA3", "somaNMDA_pyrCA3"]]
syn_inputs_neurons["pyr_ca3_to_cck_ca1"] = [["somaAMPA_pyrCA3", "somaNMDA_pyrCA3"]]

'''###########################################################################
                    External background noise
###########################################################################'''
weights_noise_neurons["bas_ca1"]["somaAMPA_noise"]   = 0.0125e-3
gain = np.linspace(1,10,21)
nois_pyr = np.linspace(0,2,11)[6]
weights_noise_neurons["pyr_ca1"]["somaAMPA_noise"]   = 5*0.0125e-3*nois_pyr
weights_noise_neurons["pyr_ca1"]["Adend3AMPA_noise"] = 0.0125e-3

##############################################################################
# remove the inhibition from the non-basket interneurons
#weights_neurons_neurons["olm_ca1_to_pyr_ca1"] = [[0]]
#weights_neurons_neurons["cck_ca1_to_pyr_ca1"] = [[0], [0]] 
#weights_neurons_neurons["cck_ca1_to_cck_ca1"] = [[0]]

''' ###########################################################################
                    Some previous functions
############################################################################'''
tick = tm.time()
current_dir = os.getcwd()

h.load_file("stdrun.hoc")
def fi():
    for i in range(0,int(simulation_time),100):
        h.cvode.event(i, "print " + str(i))

def change_bursting():
    w_new = net.burst_basal_ncl_[0].weight[0]
    for nc in net.burst_var_ncl_:
        nc.weight[0] = w_new
    for nc in net.burst_basal_ncl_:
        nc.weight[0] = 0.0

def unify_data(variable, net, cells = "cell_ca3", nr=1):
    cell = net.__dict__[cells][0]
    local_data = { cell.id: list( np.round(cell.__dict__[variable].to_python(),nr)) for cell in net.__dict__[cells] }
    all_data = pc.py_alltoall( [local_data] + [None] * (pc.nhost() - 1) )
    return all_data

'''###########################################################################
                           saving the currents
###########################################################################'''


record_specific_synapses = {}
"""
record_specific_synapses["Pyramidal CA3 cell"] = ["Adend3GABA_olm","Adend3AMPA_ec3360","Adend3NMDA_ec3360", "Adend3GABA_noise", "Adend3AMPA_noise",
                                "Adend2GABA_cck",
                                "Adend1AMPA_pyrCA3", "Adend1NMDA_pyrCA3",
                                "somaGABA_bas", "somaGABA_cck", "somaAMPA_noise", "somaGABA_noise"]
record_specific_synapses["Basket cell"] = ["somaAMPA_pyrCA3", "somaNMDA_pyrCA3"]
record_specific_synapses["CCK-expressing cell"] = ["somaAMPA_pyrCA3", "somaNMDA_pyrCA3"]
"""
'''############################################################################
                                The network
#############################################################################'''
record_mp = {"soma":True,"Bdend": False, "Adend1":False, "Adend2":False, "Adend3":False}
net = Network( weights_inputs_neurons  = weights_inputs_neurons,
               nsyns_inputs_neurons    = nsyns_inputs_neurons,
               syn_inputs_neurons      = syn_inputs_neurons,
               weights_neurons_neurons = weights_neurons_neurons,
               nsyns_neurons_neurons   = nsyns_neurons_neurons,
               syn_neurons_neurons     = syn_neurons_neurons,
               weights_noise_neurons   = weights_noise_neurons,
               delay_inputs_neurons    = delay_inputs_neurons,
               delay_neurons_neurons   = delay_neurons_neurons,
               noise_burst = noise_burst,
               bseed=27*(2*ibseed+1),   # semilla del ruido
               iseed=3421*(2*jiseed+1), # semilla para los inputs
               create_ca1_network = create_ca1_network,
               DoMakeNoise = DoMakeNoise,
               DoMakeExternalInputs = DoMakeExternalInputs,
               MakeCellStim = MakeCellStim,
               MakeNetStim  = MakeNetStim,
               MakeCellStim_python = MakeCellStim_python,
               inputs_folder = inputs_folder,
               burst_level_label = burst_level_label,
               external_inputs_label = external_inputs_label,
               #background_noise_label = background_noise_label,
               n_pyr_ca3 = 800,
               n_bas_ca3 = 100,
               n_olm_ca3 = 30,
               n_pyr_ca1 = 800,
               n_bas_ca1 = 100,
               n_olm_ca1 = 30,
               n_cck_ca1 = 70,
               connections = True,
               nseg_pyr= 3, 
               record_mp = record_mp)
pc.barrier()
tau2seq = np.linspace(1,5,21)
tauNMDAseq = np.linspace(15,40,21)
for cell in net.cck_ca1.cell:
    cell.somaInj.amp = 32.5*1e-3 # fixed 15/11
for cell in net.pyr_ca1.cell:
    cell.Adend3GABA_olm.syn.tau2 = 20.0

for cell in net.cck_ca1.cell: 
    cell.somaAMPA_ec3360.syn.tau2 = 2.5#tau2seq[input4]
for cell in net.pyr_ca1.cell: 
    cell.Adend1NMDA_pyrCA3.syn.tau1NMDA = 15#tauNMDAseq[input4]
    cell.Adend2GABA_cck.syn.tau2 = 4.0#tau2seq[input4]
    cell.somaGABA_cck.syn.tau2   = 4.0#tau2seq[input4]
    
# modification of the threshold of the cck 
for cell in net.cck_ca1.cell: 
    cell.spike_detector.threshold = -10.0
    
net.set_noise_inputs(simulation_time) # set background noise and external input
if net.MakeNetStim:
    net.init_NetStims()  # init rngs of background
if net.MakeCellStim:
    if not net.MakeCellStim_python:
        net.init_CellStims() # init rngs of external inputs

# record synaptic current in the pyramidal neurons:


'''###########################################################################
                     external inputs vecstims
############################################################################'''

inputs, vecstims = [],[]
net.inputs_list = []
net.vsl_ = []

if net.DoMakeExternalInputs:
    print("external inputs with vecstims")
    print(net.external_inputs_data.keys())
    for key in net.external_inputs_data.keys():
        if key.endswith("ca1"):
            idv      = net.external_inputs_data[key]["idv"]
            spikes   = net.external_inputs_data[key]["spikes"]
            trg      = net.external_inputs_data[key]["population"]
            syn_list = net.external_inputs_data[key]["synapses"]
            delays   = net.external_inputs_data[key]["delays"]
            w_list   = net.external_inputs_data[key]["weights"]
            conn     = net.external_inputs_data[key]["connectivity"]
            if key.startswith("ec3_360"): # "quick solution to make cck spike before"
                spikes -= 10
            for k,conn_ in enumerate(conn):
                for post_id, all_pre in enumerate(conn_):
                    net.inputs_list.append([ ])
                    for j, pre_id in enumerate(all_pre):
                        idvs = np.where(idv==pre_id)[0]
                        net.inputs_list[-1].append( np.sort(spikes[idvs]))
                        inputs.append(h.Vector( np.sort(spikes[idvs]) ))
                        vecstims.append(h.VecStim())
                        vecstims[-1].play(inputs[-1])

                        spike_list = vecstims[-1]
                        net.vsl_.append(spike_list)
                        for syn,w in zip(syn_list[k], w_list[k]):
                            net.ncl_.append(h.NetCon(spike_list, trg.cell[post_id].__dict__[syn].syn, 0, delays[k][j,trg.cell[post_id].id-trg.naux], w))
    tock = tm.time()
    diff = tock-tick
    horas = int(diff/3600)
    diff  = diff-horas*3600
    mint  = int(diff/60)
    diff  = diff-mint*60
    seg   = int(diff)

    print('Vecstim done after:', horas,'h', mint, 'min', seg, 's')
''' #######################################################################'''

pc = h.ParallelContext()
pc.set_maxstep(100*ms)
t = h.Vector().record(h._ref_t)
h.celsius = 34.0
# h.steps_per_ms = 1/h.dt
h.dt = 0.1

if(len(record_specific_synapses.keys())>0):
    for cell in net.cell_ca1:
        if(cell.name in record_specific_synapses.keys()):
            cell.syn_list = record_specific_synapses[cell.name]
            cell.record_synapses() 

if record_lfp:
    # electrode_y_coords = np.arange(0,850,50)
    zcoords = [-100,10,85,235, 385]
    # electrode_number = len(electrode_y_coords)
    electrode = {}
    electrode["ca1"] = [ ]
    for i,z in enumerate(zcoords):
        electrode["ca1"].append( LfpElectrode(x=25.0, y=25.0, z=z, sampling_period=2, neuron_type = "Pyramidal CA3"))

# h.tstop = simulation_time
# h.stdinit()

h.init()
h.finitialize()
h.fcurrent()
h.frecord_init()
h.tstop=simulation_time
h.dt = 0.1
print(h.celsius)
h.celsius = 34

#sys.exit()
pc.psolve(simulation_time*ms) # simulation running starts
t = np.array(t.to_python())
tock = tm.time()
diff  = tock-tick
horas = int(diff/3600)
diff  = diff-horas*3600
mint  = int(diff/60)
diff  = diff-mint*60
seg   = int(diff)
print("Simulation done after", horas,'h', mint, 'min', seg, 's')

################################################################################
#pc.py_alltoall: get all the results in host 0
################################################################################
pc.barrier()
print( net.pyr_ca1.cell[0].soma(0.5)._ref_v )
all_spikes, all_volt, lfp, ica = {},{},{},{}

all_spikes["ca1"] = unify_data("spike_times", net, cells="cell_ca1")
all_volt["ca1"]   = unify_data("soma_volt",   net, cells="cell_ca1",nr=4)

nets = [net.pop_ca1]


if pc.id() == 0:
    tock = tm.time()
    diff = tock-tick
    horas = int(diff/3600)
    diff  = diff-horas*3600
    mint  = int(diff/60)
    diff  = diff-mint*60
    seg   = int(diff)

    print('Simulation time with resolution dt = ', h.dt ,' ms :')
    print('_________________')
    print(' ')
    print(horas,'h', mint, 'min', seg, 's')

    all_currents = {}
    nets, regions = [net.pop_ca1],["ca1"]
    extra_label_title = "only_ca1_"

    # lfp["ca3"]= np.sum(lfp["ca3"], axis=0)/net.pyr_ca3.n
    # if net.create_ca1_network:
    #    lfp["ca1"]= np.sum(lfp["ca1"], axis=0)/net.pyr_ca1.n
    if(record_mp["soma"]):
        data_volt   = process_volt_data( all_volt, net, only_ca1=True)
    #data_volt   = process_volt_data( all_volt, net, only_ca1=True)
    data_spikes = process_spike_data( all_spikes,net, only_ca1 = True)

    # save_dir = "/home/jaime/Desktop/hippocampus/external_inputs/"
    # save_dir = os.path.join(save_dir, str(input1))
    # file_management.save_lzma(data_spikes["ca3"]["pyr"],"external_inputs_"+argvs+"_pyr_ca3",parent_dir=save_dir)

    # save_dir = os.path.join(current_folder, "ca3_data")
    # save_dir = os.path.join( save_dir, str(input1) )

    if record_lfp:
        lfp["ca1"], ica["ca1"] = [], []
        for lfp_ in electrode["ca1"]:
            lfp["ca1"].append( np.array(lfp_.values) )
            ica["ca1"].append( np.array(lfp_.values_per_section) )

        title = "lfp_"+extra_label_title+argvs
        file_management.save_lzma(lfp, title, parent_dir=save_dir)
        title = "ica_"+extra_label_title+argvs
        file_management.save_lzma(ica, title, parent_dir=save_dir)

    title = "spikes_"+extra_label_title+argvs
    file_management.save_lzma(data_spikes,title,parent_dir=save_dir)

    if(len(record_specific_synapses.keys())>0):
        recorded_specific_synapses = {}
        number_specific_synapses = {}
        for cell_type in record_specific_synapses.keys():
            recorded_specific_synapses[cell_type] = {}
            number_specific_synapses[cell_type] = 0
            for synapse_type in record_specific_synapses[cell_type]:
                ind_n = np.where([cell_type in cell_name for cell_name in [str(cell) for cell in net.__dict__["cell_ca1"]]])[0][0]
                recorded_specific_synapses[cell_type][synapse_type] = np.zeros(len(net.__dict__["cell_ca1"][ind_n].__dict__["i"+record_specific_synapses[cell_type][0]].to_python())) 
        for cell in net.__dict__["cell_ca1"]:
            if(cell.name in record_specific_synapses.keys()):
                number_specific_synapses[cell.name] = number_specific_synapses[cell.name]+1
                for synapse_type in record_specific_synapses[cell.name]:
                    recorded_specific_synapses[cell.name][synapse_type] =recorded_specific_synapses[cell.name][synapse_type]+cell.__dict__["i"+synapse_type].to_python()
        print(number_specific_synapses)
        for cell_type in record_specific_synapses.keys():
            for synapse_type in record_specific_synapses[cell_type]:
                recorded_specific_synapses[cell_type][synapse_type] = recorded_specific_synapses[cell_type][synapse_type]/number_specific_synapses[cell_type]
    
    if(record_mp["soma"]):
        title = "volt_"+extra_label_title+argvs
        file_management.save_lzma(data_volt, title, parent_dir=save_dir)
    
    if(len(record_specific_synapses.keys())>0):
        title = "currents_"+extra_label_title+argvs
        file_management.save_lzma(recorded_specific_synapses, title, parent_dir=save_dir)
    # title = "noise_background_"+extra_label_title+argvs
    # file_management.save_lzma(net.netstims_tvec, title, parent_dir=save_dir)
    # title = "noise_background_"+extra_label_title+argvs
    # file_management.save_lzma(net.netstims_ivec, title, parent_dir=save_dir)
    # title = "external_inputs_tvec_"+extra_label_title+argvs
    # file_management.save_lzma(external_inputs_tvec, title, parent_dir=save_dir)
    # title = "external_inputs_idvec"+extra_label_title+argvs
    # file_management.save_lzma(external_inputs_ivec, title, parent_dir=save_dir)

    # os.chdir(save_dir)
    # raster_plot(net,all_spikes, tmin, tmax, figtitle="raster_plot_"+argvs)
    # plot_lfp(net,t,lfp,tmin,tmax, figtitle="lfp_plot_"+argvs)
    # spiking_distributions(net, all_spikes, tmin, tmax, figtitle="spiking_distribution_"+argvs)

    tock = tm.time()
    diff = tock-tick
    horas = int(diff/3600)
    diff  = diff-horas*3600
    mint  = int(diff/60)
    diff  = diff-mint*60
    seg   = int(diff)
    
    print("All data saved after ", horas,'h', mint, 'min', seg, 's')

#error_file  = "error"+save_dir[-2:]+"_"+argvs+".log"
#output_file = "output"+save_dir[-2:]+"_"+argvs+".dat"
    error_file  = "error"+"_"+argvs+".log"
    output_file = "output"+"_"+argvs+".dat"
    os.remove(error_file)
    os.remove(output_file)

    print('data saved')
    
pc.barrier()
pc.done()
h.quit()

